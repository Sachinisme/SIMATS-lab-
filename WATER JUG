from collections import deque

def water_jug_bfs(jug1, jug2, target):
    
    queue = deque()
    visited = set()

    queue.append(((0, 0), []))   

    while queue:
        (a, b), path = queue.popleft()

        
        if a == target or b == target:
            path.append((a, b))
            return path

        if (a, b) in visited:
            continue
        visited.add((a, b))

        
        possible_states = [
            (jug1, b),          # Fill jug1
            (a, jug2),          # Fill jug2
            (0, b),             # Empty jug1
            (a, 0),             # Empty jug2
            # Pour jug1 -> jug2
            (a - min(a, jug2 - b), b + min(a, jug2 - b)),
            # Pour jug2 -> jug1
            (a + min(b, jug1 - a), b - min(b, jug1 - a))
        ]

        for state in possible_states:
            if state not in visited:
                queue.append((state, path + [(a, b)]))

    return None



jug1 = int(input("Enter capacity of Jug1: "))
jug2 = int(input("Enter capacity of Jug2: "))
target = int(input("Enter the target amount of water: "))

result = water_jug_bfs(jug1, jug2, target)

if result:
    print("\nSteps to achieve target:")
    for step in result:
        print(step)
else:
    print("No solution possible.")
